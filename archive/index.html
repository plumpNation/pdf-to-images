<html>
<body>
  <div style="margin: 20px;">
    <h2>PDF to JPEG Converter</h2>
    <input type="file" id="pdfFile" accept=".pdf" style="margin-bottom: 20px;">
    <div id="controls" style="margin-bottom: 20px; display: none;">
      <div style="margin-bottom: 15px;">
        <label>Quality: <input type="range" id="quality" min="10" max="100" value="85"> <span id="qualityValue">85</span>%</label>
      </div>
      <div style="margin-bottom: 15px;">
        <button id="selectFolder">Choose Download Folder</button>
        <span id="folderStatus" style="margin-left: 10px; color: #666;"></span>
      </div>
      <button id="exportAll">Export All as JPEGs</button>
    </div>
    <div id="pdfContainer"></div>
  </div>

  <script type="module">
    import * as pdfjsLib from 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.3.31/pdf.min.mjs';
    
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.3.31/pdf.worker.min.mjs';
    
    let pageCanvases = [];
    let pdfName = '';
    let selectedFolderHandle = null;
    const scale = 3;

    const pdfConfig = {
      disableFontFace: false,
      verbosity: 0,
      isEvalSupported: false,
      disableRange: false,
      disableStream: false,
      useSystemFonts: false
    };

    // Check if File System Access API is supported
    const supportsFileSystemAccess = 'showDirectoryPicker' in window;
    
    if (!supportsFileSystemAccess) {
      document.getElementById('selectFolder').style.display = 'none';
      document.getElementById('folderStatus').textContent = 'Folder selection not supported in this browser. Files will download to default location.';
    }

    async function selectFolder() {
      if (!supportsFileSystemAccess) {
        alert('Folder selection is not supported in this browser.');
        return;
      }

      try {
        selectedFolderHandle = await window.showDirectoryPicker();
        document.getElementById('folderStatus').textContent = `Selected: ${selectedFolderHandle.name}`;
        document.getElementById('folderStatus').style.color = 'green';
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Error selecting folder:', error);
          document.getElementById('folderStatus').textContent = 'Error selecting folder';
          document.getElementById('folderStatus').style.color = 'red';
        }
      }
    }

    async function saveToSelectedFolder(canvas, filename) {
      if (!selectedFolderHandle) {
        // Fall back to regular download
        const quality = document.getElementById('quality').value / 100;
        const dataURL = canvas.toDataURL('image/jpeg', quality);
        const link = document.createElement('a');
        link.download = filename;
        link.href = dataURL;
        link.click();
        return;
      }

      try {
        const fileHandle = await selectedFolderHandle.getFileHandle(filename, { create: true });
        const writable = await fileHandle.createWritable();
        
        const quality = document.getElementById('quality').value / 100;
        canvas.toBlob(async (blob) => {
          await writable.write(blob);
          await writable.close();
        }, 'image/jpeg', quality);
      } catch (error) {
        console.error('Error saving file:', error);
        // Fall back to regular download
        const quality = document.getElementById('quality').value / 100;
        const dataURL = canvas.toDataURL('image/jpeg', quality);
        const link = document.createElement('a');
        link.download = filename;
        link.href = dataURL;
        link.click();
      }
    }

    function createDownloadLink(canvas, filename) {
      const link = document.createElement('a');
      link.href = '#';
      link.textContent = `Download ${filename}`;
      link.style.display = 'block';
      link.style.marginBottom = '10px';
      link.style.cursor = 'pointer';
      link.style.color = 'blue';
      link.style.textDecoration = 'underline';
      
      link.addEventListener('click', (e) => {
        e.preventDefault();
        saveToSelectedFolder(canvas, filename);
      });
      
      return link;
    }

    function displayPages() {
      const container = document.getElementById('pdfContainer');
      container.innerHTML = '';
      
      pageCanvases.forEach((canvas, index) => {
        const pageDiv = document.createElement('div');
        pageDiv.style.marginBottom = '20px';
        pageDiv.style.border = '1px solid #ccc';
        pageDiv.style.display = 'inline-block';
        
        const pageLabel = document.createElement('h4');
        pageLabel.textContent = `Page ${index + 1}`;
        pageDiv.appendChild(pageLabel);
        
        // Scale down for display
        const displayCanvas = document.createElement('canvas');
        const displayCtx = displayCanvas.getContext('2d');
        displayCanvas.width = canvas.width / 2;
        displayCanvas.height = canvas.height / 2;
        displayCtx.drawImage(canvas, 0, 0, displayCanvas.width, displayCanvas.height);
        
        pageDiv.appendChild(displayCanvas);
        
        const filename = `${pdfName}_page_${(index + 1).toString().padStart(2, '0')}.jpg`;
        const downloadLink = createDownloadLink(canvas, filename);
        pageDiv.appendChild(downloadLink);
        
        container.appendChild(pageDiv);
      });
      
      document.getElementById('controls').style.display = 'block';
    }

    async function loadPDF(file) {
      pageCanvases = [];
      pdfName = file.name.replace('.pdf', '');
      document.getElementById('controls').style.display = 'none';
      
      const fileReader = new FileReader();
      fileReader.onload = async function() {
        const typedArray = new Uint8Array(this.result);
        
        try {
          const pdf = await pdfjsLib.getDocument({
            data: typedArray,
            ...pdfConfig
          }).promise;
          
          console.log(`Processing ${pdf.numPages} pages...`);
          
          // Process all pages
          for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
            try {
              const page = await pdf.getPage(pageNum);
              const viewport = page.getViewport({scale: scale});
              
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = viewport.width;
              canvas.height = viewport.height;
              
              // Fill with white background
              ctx.fillStyle = 'white';
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              
              const renderContext = {
                canvasContext: ctx,
                viewport: viewport,
                intent: 'display',
                renderInteractiveForms: true,
                annotationMode: 2
              };
              
              await page.render(renderContext).promise;
              
              // Extract and render text layer to catch missing text
              try {
                const textContent = await page.getTextContent();
                if (textContent.items && textContent.items.length > 0) {
                  console.log(`Page ${pageNum} has ${textContent.items.length} text items`);
                  
                  // Render missing text items as black overlay
                  ctx.fillStyle = 'black';
                  ctx.textBaseline = 'baseline';
                  
                  textContent.items.forEach(item => {
                    if (item.str && item.str.trim()) {
                      // Transform coordinates from PDF space to canvas space
                      const tx = item.transform;
                      const x = tx[4] * viewport.scale;
                      const y = (viewport.height - tx[5]) * viewport.scale;
                      const fontSize = Math.abs(tx[0]) * viewport.scale;
                      
                      if (fontSize > 0) {
                        ctx.font = `${fontSize}px Arial`;
                        ctx.fillText(item.str, x, y);
                      }
                    }
                  });
                  console.log(`Manually rendered text for page ${pageNum}`);
                }
              } catch (textError) {
                console.log(`Could not extract text for page ${pageNum}:`, textError);
              }
              
              // Selective contrast enhancement - only darken likely text
              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const data = imageData.data;
              
              for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Skip pure white and very light colors (backgrounds)
                if (r > 240 && g > 240 && b > 240) continue;
                
                // Only darken gray text (not colored backgrounds)
                const isGrayish = Math.abs(r - g) < 20 && Math.abs(g - b) < 20 && Math.abs(r - b) < 20;
                const brightness = (r + g + b) / 3;
                
                // Only enhance if it's grayish and in the text brightness range
                if (isGrayish && brightness > 80 && brightness < 180) {
                  // Make gray text darker
                  const factor = 0.4;
                  data[i] = Math.max(0, r * factor);
                  data[i + 1] = Math.max(0, g * factor);
                  data[i + 2] = Math.max(0, b * factor);
                }
              }
              
              ctx.putImageData(imageData, 0, 0);
              pageCanvases.push(canvas);
              console.log(`Page ${pageNum} rendered`);
              
            } catch (pageError) {
              console.error(`Error rendering page ${pageNum}:`, pageError);
              // Create a blank page
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = 600;
              canvas.height = 800;
              ctx.fillStyle = 'white';
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.fillStyle = 'black';
              ctx.font = '20px Arial';
              ctx.textAlign = 'center';
              ctx.fillText(`Page ${pageNum} - Render Error`, canvas.width/2, canvas.height/2);
              pageCanvases.push(canvas);
            }
          }
          
          displayPages();
          
        } catch (error) {
          console.error('Error loading PDF:', error);
          document.getElementById('pdfContainer').innerHTML = '<p>Error loading PDF: ' + error.message + '</p>';
        }
      };
      fileReader.readAsArrayBuffer(file);
    }

    // Export all pages
    document.getElementById('exportAll').addEventListener('click', async function() {
      if (selectedFolderHandle && supportsFileSystemAccess) {
        // Save all to selected folder
        for (let i = 0; i < pageCanvases.length; i++) {
          const canvas = pageCanvases[i];
          const filename = `${pdfName}_page_${(i + 1).toString().padStart(2, '0')}.jpg`;
          await saveToSelectedFolder(canvas, filename);
        }
        alert(`All ${pageCanvases.length} images saved to ${selectedFolderHandle.name}`);
      } else {
        // Fall back to individual downloads
        pageCanvases.forEach((canvas, index) => {
          const filename = `${pdfName}_page_${(index + 1).toString().padStart(2, '0')}.jpg`;
          const quality = document.getElementById('quality').value / 100;
          const dataURL = canvas.toDataURL('image/jpeg', quality);
          
          const link = document.createElement('a');
          link.download = filename;
          link.href = dataURL;
          link.click();
        });
      }
    });

    // Folder selection
    document.getElementById('selectFolder').addEventListener('click', selectFolder);

    // Update quality display
    document.getElementById('quality').addEventListener('input', function() {
      document.getElementById('qualityValue').textContent = this.value;
    });

    // Handle file selection
    document.getElementById('pdfFile').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (file && file.type === 'application/pdf') {
        loadPDF(file);
      } else {
        alert('Please select a valid PDF file.');
      }
    });
  </script>
</body>
</html>